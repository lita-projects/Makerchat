<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Makerchat with Voice</title>
    <style>
        :root {
            --discord-dark: #36393f;
            --discord-darker: #2f3136;
            --discord-light: #dcddde;
            --discord-accent: #7289da;
            --discord-green: #43b581;
            --discord-red: #f04747;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Helvetica Neue', sans-serif;
            background-color: var(--discord-dark);
            color: var(--discord-light);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background-color: var(--discord-darker);
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header h1 {
            font-size: 1.2rem;
            color: white;
        }

        .main-container {
            display: flex;
            flex: 1;
            min-height: 0;
        }

        .chat-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .voice-section {
            width: 250px;
            background-color: var(--discord-darker);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
        }

        .voice-header {
            padding: 1rem;
            background-color: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .voice-controls {
            padding: 1rem;
            display: flex;
            gap: 0.5rem;
            background-color: rgba(0, 0, 0, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .voice-participants {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .participant {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            border-radius: 4px;
            margin-bottom: 0.5rem;
            transition: background-color 0.2s;
        }

        .participant.speaking {
            background-color: rgba(114, 137, 218, 0.1);
        }

        .participant-info {
            flex: 1;
            min-width: 0;
        }

        .participant-name {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--discord-light);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .participant-status {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
        }

        .participant-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: var(--discord-dark);
        }

        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            display: flex;
            flex-direction: column;
        }

        .input-container {
            padding: 1rem;
            background-color: var(--discord-darker);
            display: flex;
            gap: 0.5rem;
            align-items: flex-end;
        }

        .message-input {
            flex: 1;
            padding: 0.75rem;
            border-radius: 4px;
            border: none;
            background-color: #40444b;
            color: var(--discord-light);
            resize: none;
            font-family: inherit;
            font-size: 0.95rem;
            line-height: 1.3;
            max-height: 200px;
            min-height: 40px;
        }

        .message-input:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--discord-accent);
        }

        .control-btn {
            padding: 0.75rem;
            border-radius: 4px;
            border: none;
            background-color: #40444b;
            color: var(--discord-light);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .control-btn:hover {
            background-color: #4f545c;
        }

        .control-btn.active {
            background-color: var(--discord-green);
            color: white;
        }

        .control-btn.muted {
            background-color: var(--discord-red);
            color: white;
        }

        .send-button {
            padding: 0.75rem 1.5rem;
            background-color: var(--discord-accent);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        .send-button:hover {
            background-color: #5f73bc;
        }

        .send-button:disabled {
            background-color: #72767d;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .message {
            display: flex;
            margin-bottom: 1rem;
            padding: 0.5rem;
            border-radius: 4px;
            max-width: 80%;
        }

        .message.own-message {
            margin-left: auto;
            flex-direction: row-reverse;
            background-color: var(--discord-accent);
        }

        .message.other-message {
            margin-right: auto;
            background-color: var(--discord-darker);
        }

        .message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin: 0 0.5rem;
        }

        .message-content {
            flex: 1;
            min-width: 0;
        }

        .message-header {
            display: flex;
            align-items: center;
            margin-bottom: 0.25rem;
        }

        .own-message .message-header {
            flex-direction: row-reverse;
        }

        .message-username {
            font-weight: bold;
            margin: 0 0.5rem;
        }

        .message-time {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.8rem;
        }

        .message-text {
            word-break: break-word;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }

        .status-indicator.online {
            background-color: var(--discord-green);
        }

        .status-indicator.speaking {
            background-color: var(--discord-accent);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .modal-content {
            background-color: var(--discord-dark);
            padding: 2rem;
            border-radius: 8px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            min-width: 300px;
        }

        .settings-btn {
            background: none;
            border: none;
            color: var(--discord-light);
            cursor: pointer;
            padding: 0.5rem;
            font-size: 1.2rem;
        }

        .system-message {
            text-align: center;
            padding: 0.5rem;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="header">
        <button class="settings-btn" onclick="requestNotificationPermission()" id="notificationBtn">üîî</button>
        <h1>Makerchat</h1>
        <button class="settings-btn" onclick="openSettings()">‚öôÔ∏è</button>
    </div>

    <div class="main-container">
        <div class="chat-section">
            <div class="chat-container" id="chatContainer"></div>
            
            <div class="input-container">
                <button class="control-btn" id="voiceBtn" onclick="toggleVoice()" title="Join Voice">
                    üé§
                </button>
                <textarea
                    class="message-input"
                    id="messageInput"
                    placeholder="Message #general"
                    rows="1"
                    onkeypress="handleKeyPress(event)"
                    oninput="adjustTextarea(this)"
                ></textarea>
                <button class="send-button" onclick="sendMessage()" id="sendButton">Send</button>
            </div>
        </div>

        <div class="voice-section">
            <div class="voice-header">
                <h3>Voice Channel</h3>
            </div>
            <div class="voice-controls">
                <button class="control-btn" id="micBtn" onclick="toggleMute()" title="Mute">
                    üéôÔ∏è
                </button>
                <button class="control-btn" id="deafenBtn" onclick="toggleDeafen()" title="Deafen">
                    üîä
                </button>
            </div>
            <div class="voice-participants" id="voiceParticipants">
                <!-- Participants will be added here dynamically -->
            </div>
        </div>
    </div>

    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <h2>Settings</h2>
            <div style="margin: 1rem 0;">
                <label for="usernameInput">Username</label>
                <input type="text" id="usernameInput" style="width: 100%; margin-top: 0.5rem; padding: 0.5rem;">
            </div>
            <div style="margin: 1rem 0;">
                <label for="avatarInput">Avatar URL</label>
                <input type="text" id="avatarInput" style="width: 100%; margin-top: 0.5rem; padding: 0.5rem;">
            </div>
            <button class="send-button" onclick="saveSettings()">Save</button>
        </div>
    </div>

    <script>
        let ws;
        let userData = {
            username: `User${Math.floor(Math.random() * 10000)}`,
            avatar: `https://api.dicebear.com/6.x/avataaars/svg?seed=${Date.now()}`
        };
        let isInVoice = false;

        // WebRTC configuration
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // Connect to WebSocket
        function connect() {
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${location.host}/ws/${Date.now()}`;
            
            ws = new WebSocket(wsUrl);
            
            ws.onopen = () => {
                console.log('Connected to server');
                document.getElementById('messageInput').disabled = false;
                document.getElementById('sendButton').disabled = false;
            };
            
            ws.onclose = () => {
                console.log('Disconnected from server');
                document.getElementById('messageInput').disabled = true;
                document.getElementById('sendButton').disabled = true;
                setTimeout(connect, 3000);
            };
            
            ws.onmessage = handleWebSocketMessage;
        }

        // Voice Chat Functions
        async function toggleVoice() {
            const voiceBtn = document.getElementById('voiceBtn');
            
            if (!isInVoice) {
                try {
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    isInVoice = true;
                    voiceBtn.classList.add('active');
                    
                    ws.send(JSON.stringify({
                        type: 'voice_join',
                        username: userData.username,
                        avatar: userData.avatar
                    }));
                    
                    setupVoiceActivity();
                } catch (err) {
                    console.error('Error accessing microphone:', err);
                    alert('Could not access microphone. Please check permissions.');
                }
            } else {
                leaveVoice();
            }
        }

        function leaveVoice() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            Object.values(peerConnections).forEach(pc => pc.close());
            peerConnections = {};
            
            isInVoice = false;
            document.getElementById('voiceBtn').classList.remove('active');
            
            ws.send(JSON.stringify({
                type: 'voice_leave',
                username: userData.username
            }));
        }

        function toggleMute() {
            if (!localStream) return;
            
            const micBtn = document.getElementById('micBtn');
            isMuted = !isMuted;
            
            localStream.getAudioTracks().forEach(track => {
                track.enabled = !isMuted;
            });
            
            micBtn.classList.toggle('muted', isMuted);
            
            ws.send(JSON.stringify({
                type: 'voice_state_update',
                state: { muted: isMuted }
            }));
        }

        function toggleDeafen() {
            const deafenBtn = document.getElementById('deafenBtn');
            isDeafened = !isDeafened;
            
            Object.values(peerConnections).forEach(pc => {
                pc.getReceivers().forEach(receiver => {
                    if (receiver.track.kind === 'audio') {
                        receiver.track.enabled = !isDeafened;
                    }
                });
            });
            
            deafenBtn.classList.toggle('muted', isDeafened);
            
            // Send voice state update to server
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'voice_state_update',
                    state: { deafened: isDeafened }
                }));
            }
        }

        // Voice chat state
        let localStream = null;
        let peerConnections = {};
        let isInCall = false;
        let isMuted = false;
        let isDeafened = false;

async function startVoiceChat() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        localStream = stream;
        isInCall = true;
        setupVoiceActivityDetection();
        return true;
    } catch (err) {
        console.error('Error accessing microphone:', err);
        alert('Could not access microphone. Please check permissions.');
        return false;
    }
}

function setupVoiceActivityDetection() {
    if (!localStream) return;

    const audioContext = new AudioContext();
    const source = audioContext.createMediaStreamSource(localStream);
    const analyzer = audioContext.createAnalyser();
    analyzer.fftSize = 512;
    analyzer.smoothingTimeConstant = 0.1;
    
    const processor = audioContext.createScriptProcessor(1024, 1, 1);
    
    source.connect(analyzer);
    analyzer.connect(processor);
    processor.connect(audioContext.destination);
    
    let speakingTimeout;
    
    processor.onaudioprocess = function() {
        const array = new Uint8Array(analyzer.frequencyBinCount);
        analyzer.getByteFrequencyData(array);
        
        const average = array.reduce((a, b) => a + b) / array.length;
        const isSpeaking = average > 20 && !isMuted;
        
        clearTimeout(speakingTimeout);
        
        if (isSpeaking) {
            updateSpeakingState(true);
            speakingTimeout = setTimeout(() => updateSpeakingState(false), 200);
        }
    };
}

function updateSpeakingState(isSpeaking) {
    const participantDiv = document.querySelector(`.participant[data-username="${userData.username}"]`);
    if (participantDiv) {
        participantDiv.classList.toggle('speaking', isSpeaking);
    }
    
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
            type: 'voice_state_update',
            state: { speaking: isSpeaking }
        }));
    }
}

async function createPeerConnection(targetId) {
    if (peerConnections[targetId]) {
        return peerConnections[targetId];
    }
    
    const pc = new RTCPeerConnection(rtcConfig);
    peerConnections[targetId] = pc;
    
    // Add local stream
    if (localStream) {
        localStream.getTracks().forEach(track => {
            pc.addTrack(track, localStream);
        });
    }
    
    // Handle ICE candidates
    pc.onicecandidate = event => {
        if (event.candidate) {
            sendVoiceSignal('ice_candidate', targetId, { candidate: event.candidate });
        }
    };
    
    // Handle incoming streams
    pc.ontrack = event => {
        const remoteStream = event.streams[0];
        addRemoteStream(targetId, remoteStream);
    };
    
    // Handle connection state changes
    pc.onconnectionstatechange = () => {
        if (pc.connectionState === 'failed' || pc.connectionState === 'closed') {
            cleanupPeerConnection(targetId);
        }
    };
    
    return pc;
}

function addRemoteStream(peerId, stream) {
    const participantDiv = document.querySelector(`.participant[data-client-id="${peerId}"]`);
    if (participantDiv) {
        // Create or get audio element
        let audio = participantDiv.querySelector('audio');
        if (!audio) {
            audio = document.createElement('audio');
            audio.autoplay = true;
            if (isDeafened) {
                audio.volume = 0;
            }
            participantDiv.appendChild(audio);
        }
        audio.srcObject = stream;
    }
}

function cleanupPeerConnection(peerId) {
    const pc = peerConnections[peerId];
    if (pc) {
        pc.close();
        delete peerConnections[peerId];
    }
    
    // Remove audio element
    const participantDiv = document.querySelector(`.participant[data-client-id="${peerId}"]`);
    if (participantDiv) {
        const audio = participantDiv.querySelector('audio');
        if (audio) {
            audio.srcObject = null;
            audio.remove();
        }
    }
}

async function initiateCall(targetId) {
    try {
        const pc = await createPeerConnection(targetId);
        const offer = await pc.createOffer({ offerToReceiveAudio: true });
        await pc.setLocalDescription(offer);
        
        sendVoiceSignal('voice_offer', targetId, { offer: offer });
    } catch (err) {
        console.error('Error creating offer:', err);
        cleanupPeerConnection(targetId);
    }
}

async function handleVoiceOffer(fromId, offer) {
    try {
        const pc = await createPeerConnection(fromId);
        await pc.setRemoteDescription(new RTCSessionDescription(offer));
        
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        
        sendVoiceSignal('voice_answer', fromId, { answer: answer });
    } catch (err) {
        console.error('Error handling offer:', err);
        cleanupPeerConnection(fromId);
    }
}

async function handleVoiceAnswer(fromId, answer) {
    try {
        const pc = peerConnections[fromId];
        if (pc) {
            await pc.setRemoteDescription(new RTCSessionDescription(answer));
        }
    } catch (err) {
        console.error('Error handling answer:', err);
        cleanupPeerConnection(fromId);
    }
}

async function handleIceCandidate(fromId, candidate) {
    try {
        const pc = peerConnections[fromId];
        if (pc) {
            await pc.addIceCandidate(new RTCIceCandidate(candidate));
        }
    } catch (err) {
        console.error('Error handling ICE candidate:', err);
    }
}

function sendVoiceSignal(type, targetId, data) {
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
            type: type,
            target: targetId,
            ...data
        }));
    }
}

async function joinVoiceChat() {
    if (isInCall) return;
    
    const success = await startVoiceChat();
    if (!success) return;
    
    document.getElementById('voiceBtn').classList.add('active');
    
    // Join voice chat room
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
            type: 'voice_join',
            room_id: 'default'
        }));
    }
}

function leaveVoiceChat() {
    if (!isInCall) return;
    
    // Stop local stream
    if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
    }
    
    // Cleanup all peer connections
    Object.keys(peerConnections).forEach(cleanupPeerConnection);
    peerConnections = {};
    
    isInCall = false;
    document.getElementById('voiceBtn').classList.remove('active');
    
    // Leave voice chat room
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
            type: 'voice_leave'
        }));
    }
}

function toggleVoice() {
    if (!isInCall) {
        joinVoiceChat();
    } else {
        leaveVoiceChat();
    }
}

function toggleMic() {
    if (!localStream) return;
    
    const micBtn = document.getElementById('micBtn');
    isMuted = !isMuted;
    
    localStream.getAudioTracks().forEach(track => {
        track.enabled = !isMuted;
    });
    
    micBtn.classList.toggle('muted', isMuted);
    
    // Send voice state update to server
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
            type: 'voice_state_update',
            state: { muted: isMuted }
        }));
    }
}

// Update the existing handleMessage function to handle voice-related messages
const originalHandleMessage = handleMessage;
handleMessage = function(data) {
    originalHandleMessage(data);
    
    switch(data.type) {
        case 'voice_peer_joined':
            if (isInCall) {
                initiateCall(data.client_id);
            }
            break;
            
        case 'voice_peer_left':
            cleanupPeerConnection(data.client_id);
            break;
            
        case 'voice_offer':
            handleVoiceOffer(data.from, data.offer);
            break;
            
        case 'voice_answer':
            handleVoiceAnswer(data.from, data.answer);
            break;
            
        case 'ice_candidate':
            handleIceCandidate(data.from, data.candidate);
            break;
            
        case 'voice_state_update':
            updateParticipantState(data.client_id, data.state);
            break;
    }
};

function updateParticipantState(clientId, state) {
    const participantDiv = document.querySelector(`.participant[data-client-id="${clientId}"]`);
    if (participantDiv) {
        if (state.speaking !== undefined) {
            participantDiv.classList.toggle('speaking', state.speaking);
        }
        if (state.muted !== undefined) {
            participantDiv.classList.toggle('muted', state.muted);
        }
        if (state.deafened !== undefined) {
            participantDiv.classList.toggle('deafened', state.deafened);
        }
    }
}

// Clean up voice chat when leaving
window.addEventListener('beforeunload', () => {
    leaveVoiceChat();
});
